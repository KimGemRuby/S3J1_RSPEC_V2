# S3J1_RSPEC


    avatar

    The Hacking Project


    Dashboard
    Semaine d'introduction
    D√©couverte de Ruby
    D√©couverte des tests

D√©couverte de Ruby
D√©couverte des tests
Nous allons te faire d√©couvrir le monde merveilleux du testing en code. Le test est une technique largement utilis√©e, qui permet de voir si le code fait ce qu'il devrait faire. Nous allons te demander de faire des exercices qui seront en TDD, c'est √† dire que les tests sont √©crits en premier, et il te faudra √©crire le code qui fait marcher les tests.

    Lundi
    D√©couverte des tests
    Nous allons te faire d√©couvrir le monde merveilleux du testing en code. Le test est une technique largement utilis√©e, qui permet de voir si le code fait ce qu'il devrait faire. Nous allons te demander de faire des exercices qui seront en TDD, c'est √† dire que les tests sont √©crits en premier, et il te faudra √©crire le code qui fait marcher les tests.
    Mardi
    Quelques exercices de chauffe en Ruby
    Pour ce deuxi√®me jour en Ruby, nous allons te demander de faire des petits programmes, afin de te chauffer en douceur. Ces petits programmes seront moins concrets qu'un bot Twitter, mais ils te serviront d'introduction au monde merveilleur du backend. Ainsi, tu apprendras √† jouer avec des array, des hash, et autres joyeuset√©s de ruby.
    Mercredi
    Bot Twitter
    Tu vas cr√©er tes premiers programmes qui vont jouer avec des APIs. Ainsi, nous te demanderons de faire un bot qui va sur Twitter et qui va follow, envoyer des messages, et/ou spammer les gens. √áa va √™tre rigolo üòé
    Jeudi
    L'art du scrapping
    Nous allons te montrer comment r√©cup√©rer des donn√©es en masse √† partir d'un site internet. Imagine que quelqu'un te dise "tu dois aller sur ce site, et copier-coller toutes les lignes pour les enregistrer dans un fichier texte", quelle gal√®re quand il y a 1000 lignes √† copier ! Mais heureusement gr√¢ce √† The Hacking Project, tu sauras r√©cup√©rer ces lignes avec quelques lignes de code seulement üòé
    Vendredi
    Automatisation, serialization
    Tu vas voir comment t'amuser avec ton terminal pour qu'il soit styl√©, puis faire des programmes en Ruby qui vont te m√¢cher le travail.

Ressource : Comprendre le peer learning : la m√©thodologie de THP

√Ä The Hacking Project, notre mission est d'inventer l'√©cole du futur. C'est une belle mission mais qui demande un exercice de contorsion pour nos √©l√®ves : c'est difficile de faire table rase de la m√©thode p√©dagogique que vous avez suivie jusqu'√† pr√©sent. Dans cette ressource nous allons revenir sur quelques concepts importants qu'il faut que vous ayez afin de r√©ussir au mieux la formation. Maintenant que cela fait deux semaines que tu suis The Hacking Project, tu commences √† saisir les enjeux du peer-learning. Cette ressource tombera √† point nomm√© donc !

Si tu ne l'as pas fait, nous t'invitons tout d'abord √† lire le fantastique topo de Merci Alfred qui explique pourquoi l'√©cole telle que nous la voyons est d√©pass√©e et qu'il faut repenser l'√©ducation. Cela permettra de te mettre en jambe sur notre volont√© de changer l'√©ducation.
1. Le syst√®me de notation est d√©pass√©. Vous √™tes l√† pour apprendre et non pas pour gruger des notes

Avant toute chose, sachez que The Hacking Project est une formation qui se veut difficile afin de pouvoir vous pousser dans vos retranchements. Il est tout √† fait normal que sous la pression vous oubliez cette maxime digne de votre professeur √† la fac ("vous √™tes ici pour vous et non pas pour nous") et que vous vous dites que ce n'est pas grave de prendre le r√©po d'une autre personne. Laisse-moi te convaincre que ce n'est pas une bonne id√©e.

La premi√®re raison est la plus √©vidente : tu es venu √† The Hacking Project pour apprendre √† coder. Obtenir un dipl√¥me ou une certification de paillette ne servira pas √† grand chose devant ton test technique (si tu vises la reconversion) ou lorsque tu voudras faire une page web rapide pour lancer ta boite.

Cela peut faire mal √† la t√™te, mais il est extr√™mement important que tu joues le jeu des projets et que tu les fasses sans tout pomper. Il peut √™tre int√©ressant de r√©cup√©rer une certaine ligne pour te d√©bloquer (notamment en Rails avec sa syntaxe qui ne pardonne pas), mais pomper des larges parties de l'exercice ne sert √† rien. Tu vas perdre la partie apprentissage de la formation qui est la raison principale pour laquelle tu es venu √† The Hacking Project.

Essayer de tout gratter sans r√©fl√©chir est la solution de facilit√©, mais ne tiendra pas le long court. D√©j√†, tu te crames aupr√®s de la communaut√© (les bruits de couloir vont vite), donc tu risques de te retrouver seul au moment de constituer les √©quipes de projets finaux. Ensuite cette m√©thode ne marchera pas lors des projets finaux puisque tu vas devoir faire une application de A √† Z. Si tu zappes M, tu te retrouveras bloqu√© pour le projet final. Donc si tu ne te fais pas violence maintenant, tu exploseras en plein vol dans quelques semaines, et ce sera bien plus douloureux que les quelques remue-m√©ninges que tu aurais pu faire pendant la formation.

Notre conseil : tu es l√† pour apprendre, et la meilleure fa√ßon d'apprendre est de faire s√©rieusement les projets. Tout recopier sur une autre personne est d√©j√† un manque de respect, mais aussi une contradiction avec ce pourquoi tu es venu √† THP.

C'est tout √† fait normal de ne pas r√©ussir √† faire enti√®rement un projet. Les projets sont tr√®s longs afin de vous permettre de vous d√©passer et de proposer √† ceux qui veulent faire des nocturnes de quoi s'amuser. Les corrections vous permettent de discuter avec la personne en face et de voir comment vous pourriez am√©liorer le programme. Ce n'est pas un moment de notations (nous n'avons pas de notes √† THP), mais un moment d'√©change. Arriver avec un programme qui marche mais que vous ne comprenez pas a beaucoup moins d'int√©r√™t qu'arriver avec un programme qui ne marche pas mais dont vous connaissez les lignes par coeur et avec lequel vous pouvez discuter longuement.

Notre conseil : prenez les corrections comme un moment d'√©change o√π vous allez discuter sur votre code v√©ritable et non pas un truc "qui marche mais que vous ne comprenez pas". Vous perdez tout l'int√©r√™t des corrections en faisant cela.
2. Les corrig√©s appartiennent √† l'√©cole traditionnelle et n'ont pas leur place ici

Bien souvent, les moussaillons me demandent des corrig√©s d'exercice afin de savoir "comment un pro aurait fait". Il est vrai qu'avec l'√©cole traditionnelle et le "ma√Ætre" qui donne les cours et qui incarne la voix de la raison c'est tout √† fait normal de penser corrig√©s. Cependant, le format corrig√© n'est pas adapt√© au monde moderne et encore moins √† une √©cole sans professeur. Laissez-moi vous expliquer pourquoi il faut se sortir de la t√™te la notion de corrig√©s.

En premier lieu, la notion de corrig√© impliquerait que la solution parfaite existe pour chaque probl√®me. C'est une conception tr√®s scolaire qui ne s'applique pas dans la vraie vie. En effet, si chaque probl√®me sur terre avait une solution claire et d√©finie qu'il suffirait d'appliquer pour le r√©soudre, la vie serait beaucoup simple, la paix dans monde existerait, et les petits enfants ne mourraient pas de faim. Ce n'est pas le cas : chaque probl√®me a plein de solutions diff√©rentes (comment tu peux le voir dans les corrections de pair). Il n'y a pas de bon ou de mauvais choix, il n'y a que des choix qui impliquent des cons√©quences. Par exemple : si je d√©cidais d'appliquer une s√©lection √† la formation, le niveau global serait meilleur, mais je perdrais l'aspect universel de The Hacking Project. L'objectif est de voir pour toi quelles cons√©quences tu pr√©f√®res √† d'autres.

Ainsi il faut voir la r√©solution d'un probl√®me comme l'application d'une philosophie qui t'est propre. Pour cette boucle, pr√©f√©rerais-tu l'utilisation d'une boucle while ou d'une boucle for ? Le plus important est qu'il te faut comprendre les implications de tes choix et ne pas h√©siter √† chercher pourquoi et comment. Les corrections de pairs permettent de mettre en valeur les diff√©rences entre vos travaux et tu n'auras qu'√† personnaliser le code en fonction de ce que tu auras vu. Au d√©but, tu prendras des solutions qui te semblent plus lisibles et compr√©hensibles. Puis avec le temps tu optimiseras les solutions avec ton exp√©rience : code plus court, code plus transmissible, code plus optimis√© ou autre. D'ailleurs ce qui est amusant c'est de revenir sur tes premiers projets dans deux mois, puis de voir comment tu les optimiserais. Si nous te donnons une solution que l'on aurait faite, tu te suffirais √† cette solution, tu ne te seras pas appropri√© TA solution au probl√®me, et tu partirais sur une certaine philosophie qui ne t'appartiendrait pas. Tu penserais que "c'est bon le probl√®me est r√©solu puisque la solution est forc√©ment celle du professeur". Pas vraiment, puisque ce serait une des solutions qui serait orient√©e vers une philosophie de code qui n'est peut √™tre pas la tienne. Ce n'est pas ce que nous voulons. Nous voulons t'inculquer le fait que la solution t'appartient, et tu es libre d'orienter le code dans la direction que tu veux. Veux-tu l'optimiser en m√©moire ? Veux-tu l'optimiser en vitesse ? Veux-tu le rendre lisible ? Si c'est le cas, comment d√©finis-tu lisible ? Bref, il faut voir du code comme un organisme vivant qui s'optimise avec le temps. Au tout d√©but ton code sera un peu brouillon, puis tu commenceras √† l'orienter vers une direction, puis tu affineras cette direction, et ainsi de suite.

Un autre argument est le fait qu'en entreprise tu n'auras pas de corrig√©. En effet, ce que l'on te demandera n'aura pas √©t√© fait, ne sera pas fait par quelqu'un d'autre (sinon pourquoi on te paie ?!), et tu seras livr√© √† toi-m√™me dans la r√©solution d'un probl√®me. Les seuls soutiens ext√©rieurs seront : demander √† une autre personne un conseil si tu es vraiment bloqu√© et faire une relecture du code en fin de probl√®me pour voir si ce dernier r√©pond bien au crit√®res d√©finis au d√©but de ta t√¢che, pour ainsi voir comment tu pourrais l'am√©liorer avec les conseils. Cela est exactement comment nous t'enseignons le code pendant ces semaines √† The Hacking Project et c'est l'une des raisons majeures pour laquelle nous croyons que le format actuel de l'√©cole ne pr√©pare pas au monde de demain.

Enfin, ne pas donner de corrig√© t'apprend une qualit√© qui est indispensable de nos jours : l'humilit√©. Comme nous ne donnons pas de corrig√©s officiels, le ressenti que tu as de ton code est "je sais que mon code marche, je sais qu'il n'est pas ouf mais j'ai plein de marge de man≈ìuvre pour l'optimiser quand j'aurai un meilleur niveau". Si nous t'avions donn√© un corrig√©, ton ressenti serait : "ce code est LE bon, pas besoin de faire mieux, c'est cool, probl√®me termin√©, bisous". Cela te donnerait une certaine arrogance en entretien d'embauche : "mais on m'a dit qu'il fallait faire √ßa √† l'√©cole, donc c'est forc√©ment comme √ßa qu'il faut faire !". Non, tout d√©pend de l'orientation que tu veux donner √† ton code. Chaque probl√®me a plusieurs solutions et il faut une solution qui t'appartient et qui r√©pondra mieux aux objectifs du probl√®me.

Afin de finir, j'aimerais citer Nicolas Sadirac, sulfureux premier directeur de l'√©cole 42 et pr√©sident du bocal d'EPITA, deux des √©coles les plus prestigieuses en code en France. Il faut rappeler qu'√† 42 comme √† EPITA, les corrig√©s n'existent absolument pas et leur p√©dagogie une des principales raisons du prestige de ces √©coles. Voici donc une phrase de Nicolas Sadirac qu'il aimait dire lors de sa matin√©e d'introduction √† 42 :

    "Au fait, il y a un projet √† 42, si vous y arrivez, pensez √† breveter votre solution car c'est un probl√®me qui n'a jamais √©t√© r√©solu et vous risquez de gagner un prix Nobel."
    Nicolas Sadirac

Voici l'√©tat d'esprit qui est enseign√© dans deux des √©coles de code les plus r√©put√©es au monde.
ü§ì QUESTION R√âCURRENTE

Jamy, je n'ai rien compris au probl√®me, je veux un corrig√© pour voir la solution car je n'y suis pas arriv√©.

Excellente remarque, et idem, ce n'est pas une bonne id√©e car en entreprise cette strat√©gie ne marche pas. Imagine tu viens de signer un contrat en freelance avec un client. L'option "d√©sol√© je n'y suis pas arriv√©" n'existe pas, √† moins que tu ne veuilles pas gagner d'argent. Donc il faut imp√©rativement te sortir de la t√™te que demain il existe des solutions √† tous tes probl√®mes et tout ira mieux. Dans la vraie vie cette m√©thode ne marche pas et tu vas te prendre une douche froide si tu penses que les gens vont te donner la solution sur un plateau d'argent.

Il arrive de faire l'impasse sur un probl√®me pr√©cis (personnellement, je fais "pouce !" quand on me demande de faire du r√©seau), et le syst√®me de jokers est l√† pour √ßa. Mais faire trop d'impasses implique que te lancer de mani√®re professionnelle dans ce milieu sera difficilement √† ta port√©e.
3. Ce que vous avez achet√© √† The Hacking Project : un cadre, une communaut√©

Il m'arrive que l'on me fasse des remarques du genre : "ouais je ne kiffe pas le format des cours de THP, donc je pr√©f√®re suivre ceux de Grafikart / OpenClassrooms / lire la documentation officielle", et certaines personnes sont d√©√ßues par THP. Et bien laissez-moi vous dire que c'est g√©nial et que vous avez parfaitement compris la philosophie de l'√©cole de la vie.

En effet, dans la vraie vie, vous serez la plupart du temps amen√©s √† devoir apprendre en continu, trouver les bonnes ressources, apprendre rapidement un concept pour l'appliquer pour un projet, lire plusieurs informations pour vous faire votre propre id√©e. Cette comp√©tence est indispensable au XXI√®me si√®cle et nous sommes tr√®s contents que vous alliez chercher d'autres informations en plus du cours pour approfondir et vous faire un second avis sur le cours. Donc bravo √† vous et continuez dans cette philosophie !

Pour rappel, voici ce que nous avons vendu √† The Hacking Project :

En premier lieu la curation d'un parcours pr√©cis. Avec la quantit√© de cours en ligne, il est facile d'apprendre les bases de l'informatique. Cependant, quand il s'agit de construire un parcours qui vise √† donner les cl√©s de la bo√Æte √† outils de l'informatique tout en donnant les bases du d√©veloppement web, c'est plus compliqu√© et il est dur de faire son choix. Il existe des cours Udemy, mais pas mal sont juste des tutos pas √† pas et manquent de projets progressifs. Il existe aussi l'√©cole 42, mais tu vas manger un an de C avant de toucher au web (via PHP qui plus est). Ou encore certains bootcamps en ligne comme freecodecamp ou The Odin Project, mais le premier te tient trop par la main et le dernier explique assez mal Rails. Ainsi, nous savons d√©j√† coder et nous pensons que ces 500 heures de cours te donneront les bases en informatique pour que tu puisses conna√Ætre cet univers et que tu puisses approfondir comme tu le sens √† sa fin.

En deuxi√®me lieu, nous te donnons un cadre motivant. Le syst√®me de groupe, de projets validants n'est pas l√† pour te sanctionner, mais l√† pour te motiver √† tenir. The Hacking Project est intense, et faire les 500 heures de cours tout seul sans aucun cadre n'est pas √† la port√©e de tout le monde. Il existera toujours des autodidactes solitaires qui arriveront √† apprendre le code en empruntant un bouquin √† la biblioth√®que et qui penseront que THP c'est nul et qu'ils auraient pu le faire seul, mais ce sont en g√©n√©ral des exceptions. Le cadre de The Hacking Project te donnera la force de tenir les parties intenses de la formation et c'est l'une des grandes valeurs ajout√©es de THP.

Enfin, le troisi√®me point est la communaut√© avec laquelle vous pouvez interagir, jouer, aider. C'est la force de la formation. Entre le moment o√π tu int√®gres THP jusqu‚Äô√† ce que tu obtiennes ton certificat de corsaire, tu vas rencontrer tes ‚Äúcoll√®gues‚Äù et camarades, cr√©er des affinit√©s et d√©couvrir les forces et faiblesses de chacun. Ces personnes vont constituer les premi√®res briques de ton nouveau r√©seau de connaissances professionnelles, celles sur lesquelles tu vas pouvoir t‚Äôappuyer quand un client te demandera de faire quelque chose qui sort ‚Äúl√©g√®rement‚Äù de tes comp√©tences ou quand tu seras d√©bord√© et qu‚Äôun ancien client t'appellerai pour te dire que son site ne r√©pond plus‚Ä¶. En plus, il faut √™tre clair: tu gal√®res sur des probl√®mes de code aujourd‚Äôhui, mais √ßa va continuer pendant un bout de temps, c‚Äôest juste que ce sera sur des probl√®mes plus complexes; mais du coup, si tu entretiens un bon r√©seau, tu vas √™tre tr√®s content de pouvoir poser des questions √† celles qui aiment bien faire du front et qui comprends donc un peu mieux que toi les composants React, ou m√™me celui a fait un peu plus de bases de donn√©es pendant THP et qui comprends donc le concept d‚Äôinner join ;) Ces personnes auront fait le m√™me cursus et seront pass√© par les m√™mes gal√®res que toi donc l‚Äô√©change sera forc√©ment plus facile et efficace. Mais ce seront aussi ces personnes qui t‚Äôenverrons des recommandations ou m√™me des missions quand elles seront d√©bord√©es ! Le monde du d√©veloppement est encore petit et tu seras √©tonn√© de voir √† quel point on se recroise souvent tout au long de nos carri√®res !
Conclusion

Pour conclure cette ressource sur notre philosophie, j'aimerais la r√©sumer: En gros, tu apprends, mais sans locaux sans professeur. Et c'est pour cela que c'est l'√©cole du futur. Tu es acteur de ta formation et tu apprendras ce que tu voudras y apprendre. On n'ira pas te fliquer et tu fais de la formation ce que tu veux en tirer.
Ressource : Le testing

1. Introduction

Le test en programmation, c'est toute une histoire. Le testing est un des gros points forts de Ruby, et bien tester son code est un standard de toute application moderne qui se respecte. Mais qu'est-ce que le testing, √† quoi √ßa sert, et pourquoi en faire ? C'est ce que nous allons voir dans cette ressource.

Avant de raconter la life du testing, sache que c'est tout simplement une fa√ßon de v√©rifier que ton programme marche bien. Tu pratiques le testing tous les jours en ce moment, par exemple en lan√ßant pyramid.rb et en rentrant des inputs pour voir si ton programme marche bien ; ou bien en ouvrant le fichier index.html et en v√©rifiant que ce foutu div est bien centr√©. √âvidemment, tu te doutes bien que les d√©veloppeurs pros ne vont pas lancer chaque matin chaque programme √† la main pour voir s'il marche toujours‚Ä¶il existe des fa√ßons d'automatiser cela, et c'est ce que nous allons voir ici.
2. Historique

Cette ressource peut √™tre tr√®s fournie, car l'univers du test est tr√®s grand. Afin de ne pas te perdre avec du blabla d'ing√©nieur en informatique, nous irons droit au but, et te conseillerons quelques lectures si tu veux aller plus loin.

Le test en programmation existe depuis la nuit des temps. Son automatisation date du d√©but des ann√©es 80, et toute entreprise qui se respecte teste r√©guli√®rement tout son code de mani√®re automatique.
3. La ressource
3.1. Testing ? What ? Why ?

Prenons le cas d'un programme qui demande √† l'utilisateur combien d'√©tages sa pyramide va faire avant de lui en renvoyer de la taille correspondante (au hasard hein‚Ä¶). Pour le moment, pour tester ce programme, tu rentrais √† la main dans ton terminal $ ruby pyramid.rb, puis tu testais quelques chiffres, avant de v√©rifier visuellement que le programme te renvoie la bonne pyramide.

Imagine qu'il soit possible d'√©crire un programme qui automatise √ßa pour le refaire chaque matin. Par exemple ce programme testerait des inputs comme 3, 10, 0, -5, 10932082 ou m√™me le string chiffre. Et √† chaque input, il serait capable de savoir que "si tu rentres 5, mon programme pyramid.rb va te renvoyer une pyramide √† 5 √©tages", ou encore "si tu rentres 10932082, mon programme pyramid.rb devrait te r√©pondre qu'il n'accepte que les nombres entre 1 et 25". Franchement ce serait cool, non ? Et bien le test automatique c'est √ßa !

"Mais pur√©e pourquoi je voudrais tester un truc pareil tous les matins ?" Ho du calme jeune moussaillon ! Imagine que ton programme pyramid.rb soit un service payant accessible par des milliers de clients H-24, qu'il fasse 3000 lignes de code et qu'il soit maintenu par une √©quipe de 20 d√©veloppeurs et d√©veloppeuses. Il est hors de question qu'il ne fonctionne pas, m√™me dimanche √† 3 h du matin (sinon ta start-up perd des clients) alors m√™me qu'avec 20 personnes qui le mettent √† jour r√©guli√®rement, il a de grandes chances de planter souvent. La solution ? Tester automatiquement le bon fonctionnement du programme √† chaque modification !

Un cas plus concret : prenons la plateforme de The Hacking Project. C‚Äôest tout b√™te, mais un utilisateur ne devrait pas pouvoir se connecter s'il rentre un mauvais mot de passe. Tu dois bien t'imaginer que nous ne testons pas √† la main cette fonctionnalit√© √† chaque fois que l'on propose une mise √† jour. Pourtant, une mise √† jour c'est une personne qui a chang√© des lignes de code dans un programme qu'il ne peut humainement pas conna√Ætre en entier : ce sagouin a toutes les chances d'y avoir introduit un bug. THP a donc mis en place un syst√®me qui teste les diff√©rentes fonctionnalit√©s et pages de l'application. Ainsi si l'un d'entre nous change un param√®tre qui fait planter l'autre bout de l'application, les tests diront "h√© mais ce bout de l'application plante", ce qui nous √©vite d'imposer un bug √† nos chers moussaillons.

Au final si tu n'√©cris pas de test automatis√© pour ton programme, ce sont tes clients qui le testeront pour toi. Et tu le sais bien, un client qui trouve un bug est rarement un client satisfait‚Ä¶

Le testing, qui √©tait au d√©part une bonne pratique, s'est maintenant impos√© comme un standard des applications modernes. La communaut√© Ruby insiste beaucoup pour que ses membres mettent en place une jolie stack de tests. C'est d'ailleurs une des forces du langage.
üìö INSTANT CULTURE G√â

Il existe un type de programmation qui s'appelle le Test Driven Development (TDD). C'est presque une philosophie orient√©e produit puisqu'elle consiste √† √©crire les tests AVANT de coder ton application.

La d√©marche peut para√Ætre contre-intuitive, mais elle a ses forces. En effet, en commen√ßant par √©crire ses tests, le dev doit se poser clairement la question "qu'est-ce que mon programme doit faire exactement ?". Les tests deviennent alors une sorte de cahier des charges en mode "s'il a ceci en entr√©e, mon programme doit produire cela. S'il a √ßa, il va r√©agir comme ceci. Etc." Et une fois lanc√© dans la phase de programmation, on ne perd plus de vue son objectif initial ! C'est un probl√®me courant quand on code : on digresse, on traite des cas particuliers, on se focalise sur des d√©tails et au final, on s'√©carte de ce qu'on devait produire.

Toutefois, cette approche est un peu fastidieuse pour le moment pour un moussaillon de THP. üòõ
3.2. Le test, en Ruby

Dans cette ressource, je vais te montrer comment tester automatiquement un programme simple qui dit "Bonjour Monde".
3.2.1. La gem Rspec

Pour faire du test automatique en Ruby, nous allons cr√©er un programme-testeur qui fait tourner notre programme-test√©, et qui check si les m√©thodes renvoient bien le r√©sultat souhait√©. Pour tester, la communaut√© Ruby propose deux solutions :

    Minitest, qui est directement install√© dans Ruby
    Rspec, qui est une gem tr√®s populaire

Pour choisir quoi utiliser pour les tests automatiques, il y a deux √©coles. Certains vont pr√©f√©rer Minitest, d'autres vont pr√©f√©rer Rspec. Tu pourrais t'en amuser et faire une conf√©rence lors du prochain Paris.rb intitul√©e "pourquoi [tel outil] est nul et [l'autre outil] est meilleur" et cr√©er la zizanie. Bref, pour The Hacking Project, nous allons te demander de passer par un seul outil : Rspec.
Pourquoi Rspec ? Et bien c'est une gem tr√®s populaire dans rails. Si un jour tu voudras tester automatiquement des fonctionnalit√©s comme une authentification sur ton application rails, ce sera plus simple (surtout quand on d√©bute) avec Rspec qu'avec Minitest. Donc si jamais un employeur t'interroge vigoureusement sur le pourquoi de Rspec, r√©ponds-lui simplement que c'√©tait notre choix et non pas le tiens.

On va donc commencer par installer la gem Rspec. Une gem c'est une extension de Ruby o√π des gens ont fait du code open-source sur lequel on va s'appuyer pour se m√¢cher le travail. Il existe plein de gems, par exemple celle qui transforme un fichier HTML / CSS en PDF, ou encore celle qui ajoute des jolies couleurs de terminal √† tes programmes. Pour l'installer, rien de plus simple sur ton terminal :

$ gem install rspec

Et hop, ta version de Ruby utilise bien Rspec. C'est merveilleux.
3.2.2. Un dossier Ruby bien test√©

Maintenant que tu as Rspec d'install√©, il nous reste √† tout pr√©parer pour bien ranger nos tests au sein de notre dossier-projet. Nous allons cr√©er un dossier spec pour h√©berger les programmes de tests, mettre en place le minimum syndical pour faire marcher la gem, puis rajouter notre application dans lib. Notre dossier ressemblera √† ceci :

my_super_test_project
‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îú‚îÄ‚îÄ ton_premier_programme.rb
‚îÇ   ‚îî‚îÄ‚îÄ ton_deuxi√®me_programme.rb
‚îú‚îÄ‚îÄ spec
‚îÇ   ‚îú‚îÄ‚îÄ spec_helper.rb (un fichier de configuration de rspec)
‚îÇ   ‚îî‚îÄ‚îÄ ton_premier_programme_spec.rb
‚îî‚îÄ‚îÄ .rspec

Tu as bien compris que pour tester de mani√®re automatique tes programmes, il te faut d'autres programmes (logique, non ?). En gros, tu vas faire un programme pyramid_spec.rb qui testera ton programme pyramid.rb. Nous pourrions tout mettre dans un m√™me dossier, mais le bordel c'est nul : on finit toujours par le regretter. La convention c'est donc :

    Tes programmes "applicatifs" dans un dossier lib,
    Tes programmes "testeurs" dans un dossier spec.

‚ö†Ô∏è ALERTE ERREUR COMMUNE

Quand tu utilises rspec, tous tes fichiers de test devront finir par _spec.rb. C'est une convention.

Faisons-le pas √† pas. Cr√©√© donc un dossier my_super_test_project dans lequel tu vas te mettre. Rentre la ligne suivante :

$ rspec --init

Cette ligne a pour effet d'installer Rspec dans ton dossier. Elle va cr√©er un dossier qui s'appelle spec, un fichier dans ce dossier qui s'appelle spec_helper.rb, puis un fichier qui s'appelle .rspec. Rien de bien croustillant pour le moment (ce sont des fichiers de configuration), mais c'est un bon d√©but.

Maintenant cr√©e un fichier hello.rb dans un dossier lib, et rajoute-lui une m√©thode qui affiche "Hello world !". Comme ceci :

def hello
  return "Hello world!"
end

Tu as fait ton programme, c'est g√©nial. Maintenant nous allons le tester. Cr√©e dans le dossier spec un fichier hello_spec.rb qui contient les lignes suivantes :

require_relative '../lib/hello'

describe "the hello function" do
  it "says hello" do
    expect(hello).to eq("Hello world!")
  end
end

D√©cortiquons ce mini programme :

    require_relative '../lib/hello' dit juste √† notre programme "hey, je vais vouloir acc√©der au contenu du fichier hello.rb qui est dans le dossier lib qui se trouve dans le dossier parent (d'o√π le ../) de l√† o√π tu es".
    describe "the hello function" do (...) end permet d'ouvrir un premier groupe de tests que l'on a appel√© "the hello function". Comme son nom l'indique, ce groupe de tests automatiques va se focaliser sur ce que doit faire la fonction "hello".
    it "says hello" do (...) end permet d'ouvrir un premier test au sein du groupe de test "the hello function". Nous avons intitul√© ce test "says hello" car c'est pr√©cis√©ment ce comportement qu'on va tester sur la fonction hello.
    expect(hello).to eq("Hello world!") est le c≈ìur m√™me du test ! On a indiqu√© via expect(..) qu'on va ex√©cuter la fonction hello. Puis le .to eq(..) permet de sp√©cifier le r√©sultat attendu : un string "Hello world!"

TADAAAAM ! Tu viens d'√©crire ton premier programme de test automatis√© en Ruby via Rspec (note cette phrase pour la balancer ce soir √† tes potes √©bahis).
3.2.3. Faire ses tests

Pour tester ton application, tu as juste √† faire (en √©tant √† la racine de ton dossier-projet) :

$ rspec

Si tout va bien, tu devrais avoir des lignes qui te confirment que ton programme a test√© une chose et qu'il n'y a pas d'erreur. C'est merveilleux.
‚ö†Ô∏è ALERTE ERREUR COMMUNE

Rspec ne marche pas si jamais tu as un espace dans un nom de fichier ou dans un nom de dossier parent. √áa te renverra une erreur qui fait tr√®s peur. Par exemple voici le working directory ($ pwd) d'un chemin qui ferait planter Rspec :

home/first_name/The Hacking Project/Semaine 2/Lundi/my_super_test_project

Si tu as √ßa, remplace les espaces dans les noms de dossier par des _ et tout ira bien. En gros :

# BAD:
/Documents/My Homework/ruby

# GOOD:
/Documents/my_homework/ruby

4. Points importants √† retenir

Tester son code c'est tr√®s important pour qu'il fonctionne √† moyen terme. Pour tester en Ruby, les deux outils les plus importants sont Minitest et Rspec ; pour THP nous allons prendre Rspec.

Rspec est une gem qu'il faut installer, puis nous pouvons la brancher dans un dossier Ruby en faisant $ rspec --init. Les fichiers de test se trouvent dans un dossier spec et ont un nom qui finit par _spec.rb.

Les lignes de base d'un programme de test en Rspec sont :

    require_relative '***' pour faire appel au programme test√© (sinon ses m√©thodes ne sont pas accessibles par le programme de test
    describe "***" do (...) end pour introduire un groupe de test, g√©n√©ralement ax√© sur une m√©thode donn√©e
    it "***" do (...) end pour introduire un test pr√©cis au sein de ce groupe, g√©n√©ralement ax√© sur une fonctionnalit√© donn√©e
    expect(lmethode_ou_variable_ou_autre).to eq(resultat_attendu) pour faire le test qu'une m√©thode ou variable ou autre donne le r√©sultat attendu

5. Pour aller plus loin

On aime bien l'article de TheBalanceCareers qui vulgarise assez bien les types de tests.

Aussi, tu peux aller sur le site de la gem Rspec. Ou tu peux aller jeter un ≈ìil sur le repo GitHub de la gem. Mais ne t'attarde pas trop non plus dessus, car nous avons pr√©vu plein d'exercices pour que tu puisses comprendre Rspec en mode #au_top.
Projets : Des exercices, des tests

2. Le projet

Ce projet vise plut√¥t √† vous faire d√©couvrir Rspec que de vous challenger sur des exercices Ruby. Les exercices sembleront abstraits (surtout au d√©but), mais c'est une bonne intro √† Ruby avant de plonger dans l'univers des bots ;)
Ce projet vous permettra √† la fois de faire des programmes simples en codant des m√©thodes, puis de vous donner un aper√ßu sur les tests. Pour cet exercice, les tests seront d√©j√† r√©dig√©s et vous donneront un cadre de travail pour coder le programme correspondant. Vous y parviendrez par it√©ration.

Voici comment √ßa marche : nous vous donnons un grand repo Github, dans lequel il y a plein de programmes de test qui disent "la m√©thode bonjour devrait dire bonjour". Sauf que la m√©thode bonjour ne dit pas bonjour, et les r√©sultats des tests vont dire "la m√©thode bonjour devrait dire bonjour mais elle ne dit pas bonjour, le test n'a pas r√©ussi : il rate". Avant de faire comme Vald et d'impliquer les mamans de tout le monde dans cette affaire, votre mission est de faire que le programme de test la boucle un peu. Pour cela, modifiez le programme test√©, faites lui dire bonjour et les tests devraient passer !

Mettre en place le projet peut faire un peu peur, mais c'est assez simple ne vous en faites pas : c'est une excellente opportunit√© pour vous apprendre √† lire des docs et manipuler des dossiers Ruby. Ce sera une journ√©e remplie d'erreurs, mais une occasion parfaite pour vous apprendre √† lire les erreurs du terminal, √† essayer de les comprendre, et ainsi √† mieux rebondir.

Sans plus tarder, voici le r√©pository GitHub qui contient les exercices √† faire aujourd'hui. Bonne chance !
3. Rendu attendu

Un joli fork du repository GitHub concern√©, avec les tests qui marchent ! Un fork est une copie d'un repo effectu√©e via GitHub : pour forker, cliquez sur le bouton "Fork" en haut √† droite du repo.

Bien √©videmment, essayez de coder des vrais programmes qui pourraient accepter n'importe quelle donn√©e en entr√©e. Les petits malins qui ne g√®rent que les 2 cas de test, juste pour les faire r√©ussir, ne vont pas apprendre grand-chose. Volkswagen a essay√©, ils ont eu des probl√®mes.
Mise en ligne du projet
ATTENTION

Nous n'avons pas re√ßu ton projet pour le moment. Si c'est encore le cas √† minuit, un joker te sera d√©compt√©.
Mise en ligne des liens
